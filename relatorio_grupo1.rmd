---
title: "Lung Adenocarcinoma Analysis (TCGA, GDC)"
author:
- Artur Gomes | PG55692
- Catarina Gomes | PG55694
- Maria Carvalho | PG55130
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
  pdf_document: default
  word_document: default
---
<img src="EEUMLOGO.png" alt="Logo da Empresa" style="float:right; margin: 10px 10px 0 0; width: 110px; height: auto;" />

# {.tabset} 


## Dataset Download and Import

This analysis is conducted in R using Bioconductor packages and other essential libraries for statistical and machine learning applications. 

In this section, we will perform the following tasks: install and load the required packages, query and download gene expression data using the GDC data portal, and import the data into a suitable structure for downstream analysis.

### Installation and Import of Packages

This section presents all the packages used in this work, which support data acquisition and analysis throughout the document, enhancing the efficiency of retrieving and interpreting relevant information. The code checks whether each package is already installed and installs it if necessary.

```{r, results='hide', warning = FALSE, message=FALSE}

# Install BiocManager if not already installed
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

# List of Bioconductor packages
bioc_packages <- c(
  "TCGAbiolinks",
  "DESeq2",
  "Biobase",
  "genefilter",
  "pheatmap",
  "org.Hs.eg.db",
  "fgsea",
  "SummarizedExperiment",
  "Glimma",
  "edgeR",
  "AnnotationDbi"
)

# Install missing Bioconductor packages
for (pkg in bioc_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    BiocManager::install(pkg, ask = FALSE)
  }
}

# List of CRAN packages
cran_packages <- c(
  "jpeg",
  "ggbeeswarm",
  "ggplot2",
  "xfun",
  "factoextra",
  "Rtsne",
  "gplots",
  "RColorBrewer",
  "tidyverse",
  "rpart",
  "rsample",
  "caret"
)

# Install missing CRAN packages
for (pkg in cran_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
}

```

### Load Packages  

After installing the required packages, we need to load them into our R environment. The following command ensures all libraries are available for analysis:

```{r,results='hide', warning = FALSE, message=FALSE}
library(BiocManager)
library(jpeg)
library(TCGAbiolinks)
library(Biobase)
library(DESeq2)
library(ggbeeswarm)
library(genefilter)
library(pheatmap)
library(org.Hs.eg.db)
library(fgsea)
library(ggplot2)
library(xfun)
library(SummarizedExperiment) 
library(factoextra)
library(Rtsne)
library(gplots)
library(edgeR)
library(AnnotationDbi)
library(RColorBrewer)
library(tidyverse)
library(rpart)
library(rsample)
library(caret)
```

### Data Query and Preparation

The **`GDCquery()`** function is used to perform a query on the database. In this function, several parameters are defined to filter the dataset that will later be downloaded.

The **`project`** parameter corresponds to the ID assigned to the cancer type, allowing the selection of information specifically related to endometrial carcinoma of the uterine body. The **`data.category`** parameter is used to specify the data category to be selected. In this case, since the goal is to perform transcriptomic analysis, the category **"Transcriptome Profiling"** was selected to retrieve gene expression profiling data.

Among the available gene expression profiling data, the analysis was restricted to gene expression quantification by setting **`data.type`** to **"Gene Expression Quantification"**. Finally, the desired type of gene expression analysis was specified, opting for **"STAR-Counts"**. This workflow indicates that the algorithm used to count gene expression from aligned sequences was based on the **STAR** tool.

The **`GDCdownload()`** function is then used to download the data according to the query defined in the previous step. Next, the **`GDCprepare()`** function was used to generate a **`SummarizedExperiment`** object, compiling all the downloaded data into a single object to facilitate further analysis. It is worth noting that this function also allows saving the data in **.RData** format, making it easier to reload using the **`load()`** function.

> **Note**: This workflow enables the simultaneous download of both gene expression data and the associated metadata for the samples and genes.

```{r, message = FALSE}
# Define the base directory
#base_dir <- "/Users/mariacarvalho/Desktop/Mestrado/2º\ semestre/Extração"  # Change this to your desired path

base_dir <- "C:\\Users\\catar\\OneDrive\\Ambiente de Trabalho\\extracao\\projeto_r\\dadossss"


# Create directory if it doesn't exist
if (!dir.exists(base_dir)) {
  dir.create(base_dir, recursive = TRUE)
}

# File path for storing processed data
gdc_data <- file.path(base_dir, "GDCdata")
rna_seq_file <- file.path(base_dir, "mRNA_TCGA-LUAD.rda")

# Check if the data file already exists, if not, download and process
if (!file.exists(rna_seq_file)) {

  query_LUAD <- GDCquery(
    project = "TCGA-LUAD",
    data.category = "Transcriptome Profiling",
    data.type = "Gene Expression Quantification",
    workflow.type = "STAR - Counts"
  )

  GDCdownload(query = query_LUAD, directory = gdc_data)

  rna_seq_LUAD <- GDCprepare(
    query = query_LUAD,
    save = TRUE,
    save.filename = rna_seq_file,
    directory = gdc_data
  )

} else {
  rna_seq_LUAD <- get(load(rna_seq_file))
  rm(data)
}

```


## Contextualization of the Data

The **TCGA-LUAD (The Cancer Genome Atlas - Lung Adenocarcinoma) project** is part of the Genomic Data Commons (GDC), aimed at characterizing lung adenocarcinoma at the molecular level. It provides **clinical, genomic, and molecular** data, including patient demographics, tumor characteristics, sequencing data, and protein expression profiles.

### Dataset Composition

The TCGA-LUAD collection encompasses **600 lung adenocarcinoma samples** with extensive molecular profiling. The transcriptomic data captures expression levels for approximately **60,000 genes**, providing unprecedented breadth in molecular characterization. Following rigorous quality control and preprocessing procedures, **27,326 genes** were retained for downstream analysis, ensuring both data quality and comprehensive coverage of the transcriptome.

### Research Focus

This study focuses on analyzing **data and metadata** to assess quality, completeness, and usability. By examining metadata, we evaluate its role in ensuring data consistency, accessibility, and interoperability for research applications.

### Objectives

This project aims to:
- Identify differentially expressed genes (DEGs) in LUAD
- Investigate associations between gene expression and clinical variables
- Discover biomarkers or gene signatures for prognosis or treatment

### Research Applications

The richness and scale of this dataset make it an invaluable resource for:
1. **Expression Profiling**: Mapping transcriptional activity across the genome in lung adenocarcinoma
2. **Molecular Subtyping**: Classifying tumors into distinct biological and clinical entities
3. **Pathway Analysis**: Investigating dysregulated biological pathways driving LUAD development
4. **Integrative Analysis**: Combining transcriptomic data with other molecular layers and clinical information

### Significance in Lung Cancer Research

The comprehensive nature of the TCGA-LUAD dataset supports efforts in understanding the molecular mechanisms driving lung adenocarcinoma and developing personalized therapeutic strategies. By integrating clinical variables with genomic data, this resource enables a multidimensional approach to investigating one of the most common and lethal cancer subtypes.


## Data Pre Processing

In this stage, we preprocess the dataset to ensure its quality for differential expression and enrichment analysis. First, we separate the gene expression data from the metadata, structuring the dataset for efficient analysis. Then, we apply filtering techniques to remove noise, retaining only biologically relevant information that will enhance the accuracy of downstream analyses.


```{r}
# Extract gene expression matrix
expression_data <- as.data.frame(assay(rna_seq_LUAD))

# Extract clinical metadata
clinical_data <- colData(rna_seq_LUAD)

# Check the first few rows of each dataset
head(expression_data)[,1:5]  
head(clinical_data)

```

###Initial Data Exploration

```{r}
# Filter genes with low expression
keep_genes <- rowSums(expression_data > 1) > ncol(expression_data) * 0.5
expression_filtered <- expression_data[keep_genes, ]

cat("Dimensions:", dim(rna_seq_LUAD)[1], "genes x", dim(rna_seq_LUAD)[2], "samples\n")

# Summaries
summary(expression_filtered[1:5, 1:5])  
summary(clinical_data)

cat("Genes:", nrow(expression_filtered), "\n")
cat("Samples:", ncol(expression_filtered), "\n")

# Gene-wise statistics
gene_stats <- data.frame(
  Mean = rowMeans(expression_filtered),
  SD = apply(expression_filtered, 1, sd)
)
summary(gene_stats)
```

#### Gene and Sample Metadata

```{r}
gene_metadata <- rowData(rna_seq_LUAD)
sample_metadata <- colData(rna_seq_LUAD)
cat("Gene metadata:", dim(gene_metadata), "\n")
cat("Sample metadata:", dim(sample_metadata), "\n")
```

### Missing Values (NA)

We analyze missing values in the dataset to identify patterns, assess their impact, and determine the best approach for handling them, ensuring data integrity for further analysis.

```{r}
# For expression_data (gene expression matrix)
percent_missing_expression = colSums(is.na(expression_data)) / nrow(expression_data) * 100

# For clinical_data (clinical_data)
percent_missing_clinical = colSums(is.na(clinical_data)) / nrow(clinical_data) * 100

percent_missing_expression
percent_missing_clinical
```
There were no NAs for the `gene expression matrix`. In the `clinical_data` some values are missing (NA). We need to remove or impute these values to avoid bias.

```{r}
columns_with_na = names(clinical_data)[colSums(is.na(clinical_data)) > 0]

# Variables with NAs
print(columns_with_na)

```

A table was created listing the variables and their corresponding missing values (NAs) to help identify which variables were selected for this analysis.

```{r}
tabela_nas = data.frame(Variável = names(clinical_data), 
                         Total_NAs = colSums(is.na(clinical_data)))

print(tabela_nas)
```

As a general rule in data preprocessing, variables with a high proportion of missing values can introduce bias or reduce the power of statistical analyses. Therefore, we chose to exclude variables with more than 30% missing values. This threshold strikes a balance between preserving as much data as possible while ensuring that the retained variables are informative and complete enough for meaningful analysis.
By applying this filter, we focused the dataset on the most relevant and reliable features, which will improve the robustness of the downstream statistical and bioinformatic analyses.


```{r}
# Set the NA threshold
threshold = 30  # in percent

# For clinical data
clinical_data_filtered = clinical_data[, percent_missing_clinical <= threshold]

columns_with_no_na <- names(clinical_data_filtered)[colSums(is.na(clinical_data_filtered)) == 0]

columns_with_no_na
```
After filtering the variables, we selected the following as our feature variables:
  `gender` : Biological sex of the patient (Male or Female --> Categorical Variable). Can influence disease prevalence and progression.
  
```{r}
## GENDER

barplot(table(clinical_data_filtered@listData[["gender"]]), 
        main = "Distribution of Gender", 
        xlab = "Gender", 
        ylab = "Count", 
        col = c("pink", "slategray1")[match(names(table(clinical_data_filtered@listData[["gender"]])), c("female", "male"))],
          border = "white")

```
  
  `race`: Self-reported racial background of the patient (Asian, American indian or Alaska native, Black or African American, White, Not Reported, Unknown --> Categorical Variable). May reflect epidemiological or socio-demographic patterns.
```{r}
## RACE

race_data <- clinical_data_filtered@listData[["race"]]
race_table <- table(race_data)


race_percent <- prop.table(race_table) * 100

race_df <- data.frame(
  Race = names(race_table),
  Count = as.vector(race_table),
  Percentage = round(as.vector(race_percent), 1)
)

print(race_df)



```
  Since the majority of patients are White (77.7%) or Black/African American (9.8%), and all other racial groups represent less than 2% each, we chose to focus our analysis on these two groups to ensure statistical relevance and interpretability.
  
```{r}
# Keep only rows where race is white or black or african american
clinical_data_filtered <- clinical_data_filtered[
  clinical_data_filtered@listData[["race"]] %in% c("white", "black or african american"),]
```

```{r}
barplot(table(clinical_data_filtered@listData[["race"]]),
        main = "Distribution of Race",
        xlab = "Race",
        ylab = "Count",
        col = c("lightseagreen", "salmon"),
          border = "white")
```
  `age_at_diagnosis`: Age of the patient at the time of initial diagnosis (In days --> Numerical Variable).
```{r}

age_in_years <- clinical_data_filtered@listData[["age_at_diagnosis"]] / 365.25

hist(age_in_years,
     main = "Age at Diagnosis Distribution",
     xlab = "Age",
     col = "snow3",
     breaks = 30,
       border = "white")  # adjust for bin size

```
  `primary_diagnosis`: Main clinical diagnosis assigned to the patient (Type of tumor --> Categorical Variable). Will help us understand if the type of the tumor will have influence in our response variable.

```{r}
diagnosis_data <- clinical_data_filtered@listData[["primary_diagnosis"]]
diagnosis_table <- table(diagnosis_data)
diagnosis_percent <- prop.table(diagnosis_table) * 100
diagnosis_percent
```
Since the majority of cases are concentrated in Adenocarcinoma, NOS (56.19%) and Adenocarcinoma with mixed subtypes (14.48%), and the other tumor types each represent less than 1%, with the 'Not Reported' category also being excluded, we will focus our analysis on these two tumor types to ensure statistical relevance and improve the interpretability of the results.
```{r}
# Filter out diagnoses with percentages < 1%
filtered_diagnosis <- diagnosis_percent[diagnosis_percent >= 1]

# Remove "Not Reported" from filtered diagnoses
final_diagnosis <- filtered_diagnosis[names(filtered_diagnosis) != "Not Reported"]

# View the final filtered data
final_diagnosis

```


```{r}

# Set colors (1 per type)

colors <- c("#6A0572", "#9D0191", "#FF6464", "#FFAB73", "#FFC93C", "#F9F871")


# Plot
# Example of a pie chart
pie(
  final_diagnosis,
  main = "Primary Diagnosis",
  col = colors,
  border = "white"
)

```

  
  `tissue_type`: Indicates the type of sample (Tumor, Normal --> Categorical Variable). Useful for distinguishing between diseased and control samples.
  
```{r}
barplot(table(clinical_data_filtered@listData[["tissue_type"]]),
        main = "Distribution of Tissue Type",
        xlab = "Tissue Type",
        ylab = "Count",
        col = c("forestgreen", "darkred"),
          border = "white")
```
  
The response variable chosen is: `vital_status`. Indicates whether the patient is Alive or Dead at follow-up (Categorical Variable). It has a binary classification target. For us it will be useful for survival outcome prediction.

```{r}
barplot(table(clinical_data_filtered@listData[["vital_status"]]),
        main = "Distribution of Vital Status",
        xlab = "Vital Status",
        ylab = "Count",
        col = c("plum", "plum4"),
          border = "white")

```


To ensure the reliability of downstream analyses, genes with low expression across the majority of samples were filtered out. Specifically, only genes with counts greater than 1 in more than 50% of the samples were retained. This step helps reduce noise from lowly expressed or non-informative genes.

```{r}
# Keep only genes where at least 50% of samples have counts >1
keep = rowSums(expression_data > 1) > (0.5 * ncol(expression_data))
filtered_data = expression_data[keep, ]

```


## Differential expression and enrichment analysis

### Differential expression analysis
#### DESEQ2

In order to analyze the genes that are differentially expressed in the tumor type **“Adenocarcinoma, NOS”** within **Lung Adenocarcinoma** (TCGA, GDC), based on the patients’ vital status, a data pre-processing step was performed to facilitate and optimize the differential expression analysis while reducing computational time and resource usage.


```{r}
final_diagnosis

```

Initially, samples with the primary diagnosis **“Adenocarcinoma, NOS”** were filtered, as only these samples are relevant to our study due to the higher incidence of this cancer subtype. 


```{r}
diagnosis_table

filtered_diagnosis = filtered_diagnosis[final_diagnosis == "Adenocarcinoma, NOS"]
data_ADC = expression_data[,rownames((filtered_diagnosis))]
dim(data_ADC)
```

```{r}
metadata_col = SummarizedExperiment::colData(rna_seq_LUAD)
geneExp = SummarizedExperiment::assay(rna_seq_LUAD, "unstranded")

filtered_data = metadata_col[!is.na(metadata_col$primary_diagnosis),]
filtered_data = filtered_data[filtered_data$primary_diagnosis=="Adenocarcinoma, NOS",]

ADC_data = geneExp[,rownames(filtered_data)]
dim(ADC_data)

```
The dataset still contained 60,660 genes, because there weren´t any missing values found in the gene expressio, on the previous analysis. Therefore, an additional filtering step was necessary to remove genes with no expression (i.e., genes that have zero counts across all samples). Furthermore, genes with very low expression were also removed, as they typically do not provide meaningful insights in differential expression analysis. To achieve this, genes were excluded if they did not have at least 20 counts in at least 4 samples. These filtering thresholds are considered standard according to the DESeq2 workflow documentation.


```{r}
sum(is.na(filtered_data$vital_status))
```
 Next, we checked for missing values in the **vital status** column. Since no missing values were found, the “vital_status” metadata was converted into a factor, as the differential expression analysis using the **DESeq2** package recommends using factors instead of character variables.
 
```{r}
filtered_data$vital_status = factor(filtered_data$vital_status)


ddsSE = DESeqDataSetFromMatrix(countData = ADC_data, colData = filtered_data, design = ~vital_status)


# filtragem de genes com menos de 20 ocorrências em pelo menos 4 amostras
keep_genes = rowSums(counts(ddsSE) >= 20) >= 4
ddsSE = ddsSE[keep_genes, ]
dim(ddsSE)

```
After the preprocessing steps, the final dataset included approximately **33,293 genes** and **323 samples**. With this filtered dataset, we created the **DESeqDataSet** object, using the “vital_status” factor as the explanatory variable in the model.

```{r}
ddsSE_norm = DESeq(ddsSE)
res = results(ddsSE_norm, alpha = 0.05)

summary(res) # summary of differential expression test results
```
```{r}
sum(res$padj < 0.05, na.rm=TRUE) # Total number of genes with differential expression
```
Differential gene expression analysis was performed using DESeq2 on a dataset comprising 33,293 genes with non-zero read counts. Throughout the analysis pipeline, standard steps such as normalization via size factor estimation, dispersion estimation, and model fitting were carried out. Gene-specific dispersion estimates were refined through modeling the mean-dispersion relationship, and outliers were identified and replaced for 8,521 genes, provided that the minimum number of replicates (set to 7) was met. Importantly, all original counts were preserved for reference.

Following model fitting and hypothesis testing, a total of 5,994 genes were found to be differentially expressed with an adjusted p-value below 0.05. Among these, 1,496 genes (approximately 4.5% of the total) were significantly upregulated, while 4,498 genes (14%) were downregulated. Notably, no genes were removed due to outlier filtering or low counts, indicating the robustness of the dataset and the strength of the detected expression changes.

This analysis highlights a considerable shift in gene expression, particularly toward downregulation, which may reflect underlying biological processes or responses in the studied conditions.

```{r}
#  graphical display of results
DESeq2::plotMA(res, main="DESeq2 differential expression analysis")
plotCounts(ddsSE_norm, gene=which.min(res$padj), intgroup="vital_status", pch = 19)

```


```{r}
plotCounts(ddsSE_norm, gene=which.min(res$padj), intgroup="vital_status", pch = 19)

resOrdered = res[order(res$padj),]
resOrdered[1,]
```

Differential expression analysis revealed that approximately 19% of genes were significantly altered between the "Alive" and "Dead" groups, with a clear trend toward downregulation. This pattern was supported by the MA plot, which showed a greater number of genes with negative fold changes.

Further exploration of individual genes through boxplots provided additional insight. The gene ENSG00000162374.18 exhibited slightly lower and more variable expression levels in the "Dead" group, suggesting potential regulatory differences. In contrast, ENSG00000202538.1 showed high expression in both groups but with reduced variability among "Dead" samples, possibly indicating more uniform gene regulation in that condition.

Together, these observations support the global trend identified in the analysis and highlight genes that may be biologically relevant in the context of survival.

### Enrichment analysis

```{r}
vital_status = as.factor(filtered_data$vital_status)
design = model.matrix(~vital_status)

dgeObj = estimateDisp(dgeObj, design = design)


fit = glmFit(dgeObj, design)

lrt = glmLRT(fit, coef=2)
topTags(lrt)


# informação acerca dos genes (subexpressos, não significativo, sobreexpresso)
summary(decideTests(lrt))

# visualização gráfica dos genes diferencialmente expressos
plotMD(lrt)
abline(h=c(-1, 1), col="lightpink3")


# glmTreat é usado para filtrar os genes DE e focar apenas nos genes que são mais biologicamente significativos
# filtrar os genes diferencialmente expressos com maior importância biológica
filtered_results = glmTreat(fit, lfc=log2(1.5))
topTags(filtered_results)


summary(decideTests(filtered_results))
plotMD(filtered_results)
abline(h=c(-1, 1), col="lightpink4")

# análise da expressão diferencial dos genes mais comumente mutados https://tcr.amegroups.org/article/view/46888/html
#PTEN(>77%), PIK3CA (53%), PIK3R1 (37%), CTNNB1 (36%), ARID1A (35%), K-RAS (24%), CTCF (20%)
#RPL22 (12%), TP53 (11%), FGFR2 (11%), and ARID5B (11%).

ALTERAR
mutant_genes = c("ENSG00000171862.11", "ENSG00000121879.6", "ENSG00000145675.15", "ENSG00000168036.18",
                  "ENSG00000117713.20", "ENSG00000133703.13", "ENSG00000102974.16", "ENSG00000116251.11",
                  "ENSG00000141510.18", "ENSG00000066468.23", "ENSG00000150347.16")

n_gene_edgeR=c()
for (gene in mutant_genes){
  n_gene_edgeR=c(n_gene_edgeR, which(rownames(filtered_results)==gene))
}
filtered_results[n_gene_edgeR,]$table


n_gene_DESeq2=c()
for (gene in mutant_genes){
  n_gene_DESeq2=c(n_gene_DESeq2, which(rownames(resultados)==gene))
}
resultados[n_gene_DESeq2,]


# analise dos genes do estudo sinalizados como diferencialmente expressos
ALTERAR GENE_ID
plotCounts(ddsSE_norm, gene=which(rownames(res)=="ENSG00000121879.6"), intgroup="vital_status", pch = 19)
plotCounts(ddsSE_norm, gene=which(rownames(res)=="ENSG00000133703.13"), intgroup="vital_status", pch = 19)


# enriquecimento Ricardo
# extração do nome de cada gene
gene_name=c()
for (gene in rownames(res)) {
  gene_name =c(gene_name,linhas_metadados[gene,"gene_name"])
}


# adição do nome de cada gene ao dataframe dos resultados da expressão diferencial
res["gene_name"] =gene_name

# salvar o data frame resultados
write.csv(res, file = "dge_deseq2.csv", row.names = T)

# carregamento do grupo de genes para a análise de enriquecimento
path = gmtPathways("h.all.v2023.2.Hs.symbols.gmt") --> ALTERAR
# Ordena os resultados pela alteração na expressão em ordem decrescente
results_ord = res[order(-res[,"log2FoldChange"]), ]
# Prepara os rankings para a FGSEA
ranks = results_ord$log2FoldChange
# associa às linhas o nome do gene
names(ranks) = results_ord$gene_name
# Identificar genes duplicados
duplicated_genes = names(ranks)[duplicated(names(ranks))]
# Remover genes duplicados
ranks = ranks[!names(ranks) %in% duplicated_genes]


# Executar a análise FGSEA com os genes não duplicados
fgseaRes = fgsea(pathways = path, stats = ranks, minSize = 15, maxSize = 500, nproc=1)
# número de vias enriquecidas
sum(fgseaRes[, padj<0.01])

res_ord = fgseaRes[order(padj),]
res_ord[res_ord[, padj<0.01]]

#salvar o resultado da análise de enriquecimento ordenado
write.csv(as.data.frame(res_ord[,1:6]), file = "enrichemnt_analysiss.csv", row.names = T)

# leitura dos resultados da análise de enriquecimento
enrichment = enrichemnt_analysiss <- read.csv("enrichemnt_analysiss.csv", row.names=1)

# através do ficheiro csv número de vias enriquecidas
sum(enrichment$padj<0.01)

head(enrichment)
```

